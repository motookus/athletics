<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>アスレチック ゲーム</title>
  <link rel="icon" href="icon.png">
  <style>
    body { margin: 0; overflow: hidden; background: black; }
  </style>
</head>
<body>
<script type="module">
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.175.0/build/three.module.js";
const scene = new THREE.Scene();

const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
camera.position.z = 5;

const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// =========================
// 立方体の足場
// =========================

class Platform {
  constructor(x,y,z,w=1,h=0.1,r=1){
    this.mesh = new THREE.Mesh(
      new THREE.BoxGeometry(w,h,r),
      new THREE.MeshBasicMaterial({color:"gray"})
    );
    this.mesh.position.set(x,y,z);
    scene.add(this.mesh);
  }
}

class killBlock {
  constructor(x,y,z,w=1,h=0.1,r=1){
    this.mesh = new THREE.Mesh(
      new THREE.BoxGeometry(w,h,r),
      new THREE.MeshBasicMaterial({color:"red"})
    );
    this.mesh.position.set(x,y,z);
    scene.add(this.mesh);
  }
}

class checkpoint {
  constructor(x,y,z,w=1,h=0.1,r=1){
    this.mesh = new THREE.Mesh(
      new THREE.BoxGeometry(w,h,r),
      new THREE.MeshBasicMaterial({color:"yellow"})
    );
    this.mesh.position.set(x,y,z);
    scene.add(this.mesh);
  }
}

let Platforms = [];
Platforms.push(new Platform(0,0,0,3.5,1.5,3.5));
Platforms.push(new Platform(0,0,-10,3.5,1.5,3.5));
Platforms.push(new Platform(0,3,-20,3.5,7.5,3.5));
Platforms.push(new Platform(0,0,-35,8.5,1.0,1.0));
Platforms.push(new Platform(0,0,-47,3.5,1.5,3.5));
Platforms.push(new Platform(0,-2.3,-20,3.5,3,3.5));
Platforms.push(new Platform(0,-0,-60,3.5,3,3.5));
Platforms.push(new Platform(0,-0,-73,3.5,3,3.5));
Platforms.push(new Platform(0,-0,-83,1,35,3));
Platforms.push(new Platform(0,20,-90,5,3,5));
Platforms.push(new Platform(0,24,-95,3,3,3))

const loader = new THREE.TextureLoader();

const texture2 = loader.load('tipitipityapatyapa.png');

const materials2 = new THREE.MeshBasicMaterial({ map: texture2 });

const texture = loader.load('bananacat.png');

const materials1 = new THREE.MeshBasicMaterial({ map: texture });  // ✅ これでテクスチャ貼れる

Platforms[5].mesh.material = materials1;
  Platforms[10].mesh.material = materials2;

let killBlocks = [];
killBlocks.push(new killBlock(0,0.8,-10,3.5,0.1,0.1));
killBlocks.push(new killBlock(0 ,2.5 ,-68 ,5 ,3 , 1));

let checkpoints = [];
checkpoints.push(new checkpoint(0,6.75,-20,2.5,0.2,2.5));
checkpoints.push(new checkpoint(0,1.5,-60,2.5,0.2,2.5));
checkpoints.push(new checkpoint(0,21.5,-90,4,0.2,4));

let gravity = 0;
let onGround = false;

let checkpointX = 0;
let checkpointY = 1;
let checkpointZ = 0;

function checkGround(){
  gravity -= 0.005;
  onGround = false;

  Platforms.forEach(p=>{
    const box = new THREE.Box3().setFromObject(p.mesh);
    const box5 = new THREE.Box3().setFromObject(Platforms[5].mesh);
    const playerBox = new THREE.Box3().setFromObject(player);

    if(box5.intersectsBox(playerBox)){
      player.position.y = 100
    }

    if(box.intersectsBox(playerBox) && gravity <= 0){
      player.position.y = box.max.y + 0.25;
      gravity = 0;
      onGround = true;
    }
  });

      killBlocks.forEach(c => {
            const killBox = new THREE.Box3().setFromObject(c.mesh);
                const playerBox = new THREE.Box3().setFromObject(player);
    if(killBox.intersectsBox(playerBox)){
          gravity = 0;
    player.position.set(checkpointX,checkpointY,checkpointZ)
    }
  })

  checkpoints.forEach(b => {
    const checkpointBox = new THREE.Box3().setFromObject(b.mesh);
    const playerBox = new THREE.Box3().setFromObject(player);
    if(checkpointBox.intersectsBox(playerBox)) {
     checkpointX = b.mesh.position.x;
     checkpointY = b.mesh.position.y + 1;
     checkpointZ = b.mesh.position.z; 
    }
  })

  player.position.y += gravity;

  if(player.position.y < -10){
    gravity = 0;
    player.position.set(checkpointX,checkpointY,checkpointZ)
  }
}

const geometry = new THREE.BoxGeometry(0.5,0.5,0.5);
const material = new THREE.MeshBasicMaterial({ color: "lime"});
const player = new THREE.Mesh(geometry, material);
scene.add(player);
player.position.set(0,1,0);

let moveSpeed = 0.1;

// キー入力管理
const keys = {};
window.addEventListener("keydown", (e) => { keys[e.code] = true; });
window.addEventListener("keyup", (e) => { keys[e.code] = false; });

// =========================
// 視点回転用の変数
// =========================
let camRotX = 0; // 上下
let camRotY = 0; // 左右
let camDist = 4; // プレイヤーとの距離

function animate() {
  requestAnimationFrame(animate);
  checkGround();

  // 移動
// =========================
// プレイヤー移動（カメラ基準）
// =========================
const forward = new THREE.Vector3();
const right = new THREE.Vector3();

if (keys["KeyW"]) {
  camera.getWorldDirection(forward);
  forward.y = 0; // 上下は無視
  forward.normalize();
  player.position.addScaledVector(forward, moveSpeed);
}
if (keys["KeyS"]) {
  camera.getWorldDirection(forward);
  forward.y = 0;
  forward.normalize();
  player.position.addScaledVector(forward, -moveSpeed);
}
if (keys["KeyA"]) {
  camera.getWorldDirection(forward);
  forward.y = 0;
  forward.normalize();
  right.crossVectors(forward, new THREE.Vector3(0,1,0)).normalize();
  player.position.addScaledVector(right, -moveSpeed);
}
if (keys["KeyD"]) {
  camera.getWorldDirection(forward);
  forward.y = 0;
  forward.normalize();
  right.crossVectors(forward, new THREE.Vector3(0,1,0)).normalize();
  player.position.addScaledVector(right, moveSpeed);
}

  if(keys['Space'] && onGround){
    gravity = 0.15;
    onGround = false;
  }

  // 矢印キーでカメラ回転
  if(keys["ArrowLeft"]) camRotY += 0.03;
  if(keys["ArrowRight"]) camRotY -= 0.03;
  if(keys["ArrowUp"]) camRotX += 0.02;
  if(keys["ArrowDown"]) camRotX -= 0.02;

  // 上下の回転制限（真後ろに回らないように）
  camRotX = Math.max(-Math.PI/3, Math.min(Math.PI/3, camRotX));

  // カメラの位置を計算（球面座標）
  const camX = player.position.x + camDist * Math.sin(camRotY) * Math.cos(camRotX);
  const camY = player.position.y + camDist * Math.sin(camRotX) + 1.5; // 少し上から見る
  const camZ = player.position.z + camDist * Math.cos(camRotY) * Math.cos(camRotX);

  camera.position.set(camX, camY, camZ);
  camera.lookAt(player.position);

Platforms[3].mesh.rotation.y += 0.01; // 前は1だった  
Platforms[8].mesh.rotation.z += 0.005; // 前は1だった  

  renderer.render(scene, camera);
}

animate();

window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>